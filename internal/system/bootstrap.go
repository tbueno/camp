package system

import (
	"camp/internal/utils"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
)

func GetDefaultBootstrapConfig() *BootstrapConfig {
	return &BootstrapConfig{
		Applications: []Application{
			{
				Name:           "nix",
				InstallCommand: "curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install --determinate",
			},
		},
	}
}

func RunBootstrap(config *BootstrapConfig, output io.Writer, dryRun bool) error {
	if config == nil {
		config = GetDefaultBootstrapConfig()
	}

	fmt.Fprintf(output, "Starting bootstrap process for %d applications...\n\n", len(config.Applications))

	for i, app := range config.Applications {
		fmt.Fprintf(output, "[%d/%d] Checking %s...\n", i+1, len(config.Applications), app.Name)

		// Check if the executable already exists
		if isCommandAvailable(app.Name) {
			fmt.Fprintf(output, "  ‚è≠Ô∏è  %s is already installed, skipping\n", app.Name)
			continue
		}

		fmt.Fprintf(output, "  Installing %s...\n", app.Name)

		if dryRun {
			fmt.Fprintf(output, "  [DRY RUN] Would execute: %s\n", app.InstallCommand)
			continue
		}

		err := executeInstallCommand(app.InstallCommand, output)
		if err != nil {
			fmt.Fprintf(output, "  ‚ùå Failed to install %s: %v\n", app.Name, err)
			return fmt.Errorf("bootstrap failed at application %s: %w", app.Name, err)
		}

		fmt.Fprintf(output, "  ‚úÖ %s installation completed\n", app.Name)
	}

	fmt.Fprintf(output, "\nüéâ Bootstrap process completed successfully!\n")
	return nil
}

// isCommandAvailable checks if a command is available in the system PATH
func isCommandAvailable(name string) bool {
	_, err := exec.LookPath(name)
	return err == nil
}

func executeInstallCommand(command string, output io.Writer) error {
	if strings.TrimSpace(command) == "" {
		return fmt.Errorf("empty install command")
	}

	cmd := exec.Command("sh", "-c", command)
	cmd.Stdout = output
	cmd.Stderr = output

	return cmd.Run()
}

// RunBootstrapWithHome runs the bootstrap process with home directory setup
func RunBootstrapWithHome(templDir utils.TemplDir, output io.Writer, dryRun bool) error {
	user := NewUser()
	campPath := user.HomeDir + "/.camp"

	fmt.Fprintf(output, "Bootstrapping your environment...\n")

	if err := bootstrapHome(campPath, templDir, output, dryRun); err != nil {
		return fmt.Errorf("failed to bootstrap home: %w", err)
	}

	if err := utils.RunCommand("nix", "--version"); err != nil {
		fmt.Fprintf(output, "Nix is not installed. Installing Nix...\n")

		if dryRun {
			fmt.Fprintf(output, "[DRY RUN] Would execute: %s/bin/install_nix\n", campPath)
		} else {
			if err = utils.RunCommand(campPath+"/bin"+"/install_nix", campPath); err != nil {
				return fmt.Errorf("failed to install nix: %w", err)
			}
		}
	}

	if user.Platform == "linux" {
		fmt.Fprintf(output, "Bootstrapping Linux...\n")
		return bootstrapLinux(campPath, templDir, user, output, dryRun)
	} else {
		fmt.Fprintf(output, "Bootstrapping macOS...\n")
		return bootstrapMac(campPath, templDir, user, output, dryRun)
	}
}

// bootstrapHome sets up the home directory structure
func bootstrapHome(campPath string, templDir utils.TemplDir, output io.Writer, dryRun bool) error {
	folders := []string{
		campPath,
		campPath + "/nix",
		campPath + "/bin",
	}

	for _, folder := range folders {
		if dryRun {
			fmt.Fprintf(output, "[DRY RUN] Would create directory: %s\n", folder)
		} else {
			if err := os.MkdirAll(folder, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %w", folder, err)
			}
		}
	}

	if err := copyBinFiles(templDir, campPath, output, dryRun); err != nil {
		return fmt.Errorf("failed to copy bin files: %w", err)
	}

	// Create default camp.yml config file
	configPath := campPath + "/camp.yml"
	if dryRun {
		fmt.Fprintf(output, "[DRY RUN] Would create config file: %s\n", configPath)
	} else {
		// Check if config already exists
		if _, err := os.Stat(configPath); os.IsNotExist(err) {
			defaultConfig := DefaultConfig()
			if err := defaultConfig.SaveConfig(configPath); err != nil {
				return fmt.Errorf("failed to create default config: %w", err)
			}
			fmt.Fprintf(output, "Created default configuration at %s\n", configPath)
		}
	}

	return nil
}

// createEnvrc creates a .envrc file in the user's home directory with direnv configuration
func createEnvrc(user *User, campPath string, output io.Writer, dryRun bool) error {
	envrcPath := user.HomeDir + "/.envrc"
	envrcContent := fmt.Sprintf("# Auto-generated by camp bootstrap\nuse flake %s/nix\n", campPath)

	if dryRun {
		fmt.Fprintf(output, "[DRY RUN] Would create .envrc file: %s\n", envrcPath)
	} else {
		if err := utils.SaveFile([]byte(envrcContent), envrcPath); err != nil {
			return fmt.Errorf("failed to create .envrc: %w", err)
		}
		fmt.Fprintf(output, "Created .envrc file at %s\n", envrcPath)
	}

	return nil
}

// bootstrapMac sets up macOS-specific configuration with nix-darwin
func bootstrapMac(campPath string, templDir utils.TemplDir, user *User, output io.Writer, dryRun bool) error {
	// Read and process darwin.nix (flake.nix)
	darwinContent, err := templDir.ReadFile("templates/initial/darwin.nix")
	if err != nil {
		return err
	}
	darwinContent = utils.ReplaceInContent(darwinContent, "__USER__", user.Name)
	darwinContent = utils.ReplaceInContent(darwinContent, "__HOME__", user.HomeDir)

	// Read home.nix (no replacements needed - nix-darwin handles user info)
	homeContent, err := templDir.ReadFile("templates/initial/home.nix")
	if err != nil {
		return err
	}

	nixHome := campPath + "/nix"
	flakePath := nixHome + "/flake.nix"
	homePath := nixHome + "/home.nix"

	if dryRun {
		fmt.Fprintf(output, "[DRY RUN] Would write darwin.nix to: %s\n", flakePath)
		fmt.Fprintf(output, "[DRY RUN] Would write home.nix to: %s\n", homePath)
	} else {
		// Save flake.nix
		err = utils.SaveFile(darwinContent, flakePath)
		if err != nil {
			return err
		}

		// Save home.nix
		err = utils.SaveFile(homeContent, homePath)
		if err != nil {
			return err
		}

		utils.BackupFile("/etc/bashrc")
		utils.BackupFile("/etc/zshrc")
		utils.BackupFile("/etc/nix/nix.conf")

		// Create .envrc file
		if err := createEnvrc(user, campPath, output, dryRun); err != nil {
			return err
		}

		fmt.Fprintf(output, "Loading nix-darwin for the first time. This may take a while...\n")
		return utils.RunCommand(campPath+"/bin"+"/bootstrap", campPath)
	}

	return nil
}

// bootstrapLinux sets up Linux-specific configuration with home-manager
func bootstrapLinux(campPath string, templDir utils.TemplDir, user *User, output io.Writer, dryRun bool) error {
	// Determine system based on architecture
	system := "x86_64-linux"
	if user.Architecture == "arm64" || user.Architecture == "aarch64" {
		system = "aarch64-linux"
	}

	// Read and process flake.nix
	flakeContent, err := templDir.ReadFile("templates/initial/flake.nix")
	if err != nil {
		return fmt.Errorf("failed to read flake.nix: %w", err)
	}
	flakeContent = utils.ReplaceInContent(flakeContent, "__USER__", user.Name)
	flakeContent = utils.ReplaceInContent(flakeContent, "__SYSTEM__", system)

	// Read and process home.nix
	homeContent, err := templDir.ReadFile("templates/initial/home.nix")
	if err != nil {
		return fmt.Errorf("failed to read home.nix: %w", err)
	}
	homeContent = utils.ReplaceInContent(homeContent, "__USER__", user.Name)
	homeContent = utils.ReplaceInContent(homeContent, "__HOME__", user.HomeDir)

	// Create minimal linux.nix that imports common modules
	linuxNixContent := `{ config, pkgs, ... }:

{
  imports = [
    ./modules/common.nix
  ];
}
`

	nixHome := campPath + "/nix"
	flakePath := nixHome + "/flake.nix"
	homePath := nixHome + "/home.nix"
	linuxPath := nixHome + "/linux.nix"

	if dryRun {
		fmt.Fprintf(output, "[DRY RUN] Would write flake.nix to: %s\n", flakePath)
		fmt.Fprintf(output, "[DRY RUN] Would write home.nix to: %s\n", homePath)
		fmt.Fprintf(output, "[DRY RUN] Would write linux.nix to: %s\n", linuxPath)
		fmt.Fprintf(output, "[DRY RUN] Would execute bootstrap script\n")
	} else {
		// Save flake.nix
		if err = utils.SaveFile(flakeContent, flakePath); err != nil {
			return fmt.Errorf("failed to save flake.nix: %w", err)
		}

		// Save home.nix
		if err = utils.SaveFile(homeContent, homePath); err != nil {
			return fmt.Errorf("failed to save home.nix: %w", err)
		}

		// Save linux.nix
		if err = utils.SaveFile([]byte(linuxNixContent), linuxPath); err != nil {
			return fmt.Errorf("failed to save linux.nix: %w", err)
		}

		// Create modules directory
		modulesDir := nixHome + "/modules"
		if err = os.MkdirAll(modulesDir, 0755); err != nil {
			return fmt.Errorf("failed to create modules directory: %w", err)
		}

		// Create minimal common.nix
		commonNixContent := `{ config, pkgs, ... }:

{
  home.packages = with pkgs; [
    # Add common packages here
  ];
}
`
		commonNixPath := modulesDir + "/common.nix"
		if err = utils.SaveFile([]byte(commonNixContent), commonNixPath); err != nil {
			return fmt.Errorf("failed to save common.nix: %w", err)
		}

		// Create .envrc file
		if err := createEnvrc(user, campPath, output, dryRun); err != nil {
			return err
		}

		fmt.Fprintf(output, "Running bootstrap script for home-manager...\n")
		if err = utils.RunCommand(campPath+"/bin"+"/bootstrap", campPath); err != nil {
			return fmt.Errorf("failed to run bootstrap script: %w", err)
		}
	}

	return nil
}

// copyBinFiles copies the bin files from the templates directory to the camp bin directory
func copyBinFiles(templDir utils.TemplDir, campPath string, output io.Writer, dryRun bool) error {
	binFiles, err := templDir.ReadDir("templates/initial/bin")
	if err != nil {
		return fmt.Errorf("failed to read directory bin: %w", err)
	}

	for _, file := range binFiles {
		if !file.IsDir() {
			destPath := campPath + "/bin/" + file.Name()

			if dryRun {
				fmt.Fprintf(output, "[DRY RUN] Would copy bin file: %s\n", destPath)
				continue
			}

			content, err := templDir.ReadFile("templates/initial/bin/" + file.Name())
			if err != nil {
				return fmt.Errorf("failed to read file %s: %w", file.Name(), err)
			}

			if err = utils.SaveFile(content, destPath); err != nil {
				return fmt.Errorf("failed to save file %s: %w", destPath, err)
			}

			// change file permissions to be executable
			if err = os.Chmod(destPath, 0755); err != nil {
				return fmt.Errorf("failed to change file permissions: %w", err)
			}
		}
	}

	return nil
}
