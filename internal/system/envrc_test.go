package system

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGetExportedVars(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected []EnvVar
	}{
		{
			name:  "basic export",
			input: "export FOO=bar",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
			},
		},
		{
			name:  "multiple exports",
			input: "export FOO=bar\nexport BAZ=qux",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
				{Name: "BAZ", Value: "qux"},
			},
		},
		{
			name:  "export with double quotes",
			input: `export FOO="bar baz"`,
			expected: []EnvVar{
				{Name: "FOO", Value: "bar baz"},
			},
		},
		{
			name:  "export with single quotes",
			input: `export FOO='bar baz'`,
			expected: []EnvVar{
				{Name: "FOO", Value: "bar baz"},
			},
		},
		{
			name:  "case insensitive EXPORT",
			input: "EXPORT FOO=bar",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
			},
		},
		{
			name:  "mixed case export",
			input: "Export FOO=bar",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
			},
		},
		{
			name:  "with comments and empty lines",
			input: "# This is a comment\nexport FOO=bar\n\n# Another comment\nexport BAZ=qux",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
				{Name: "BAZ", Value: "qux"},
			},
		},
		{
			name:  "with leading/trailing spaces",
			input: "  export FOO=bar  \n\t export BAZ=qux \t",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
				{Name: "BAZ", Value: "qux"},
			},
		},
		{
			name:  "variable names with underscores and numbers",
			input: "export FOO_BAR=test\nexport VAR_123=value",
			expected: []EnvVar{
				{Name: "FOO_BAR", Value: "test"},
				{Name: "VAR_123", Value: "value"},
			},
		},
		{
			name:     "empty input",
			input:    "",
			expected: []EnvVar{},
		},
		{
			name:     "only comments",
			input:    "# Comment 1\n# Comment 2",
			expected: []EnvVar{},
		},
		{
			name:  "non-export lines ignored",
			input: "echo hello\nexport FOO=bar\nls -la",
			expected: []EnvVar{
				{Name: "FOO", Value: "bar"},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			reader := strings.NewReader(tt.input)
			result, err := GetExportedVars(reader)

			if err != nil {
				t.Errorf("GetExportedVars() error = %v", err)
				return
			}

			if len(result) != len(tt.expected) {
				t.Errorf("GetExportedVars() got %d variables, want %d", len(result), len(tt.expected))
				return
			}

			for i, got := range result {
				expected := tt.expected[i]
				if got.Name != expected.Name || got.Value != expected.Value {
					t.Errorf("GetExportedVars()[%d] = {Name: %q, Value: %q}, want {Name: %q, Value: %q}",
						i, got.Name, got.Value, expected.Name, expected.Value)
				}
			}
		})
	}
}

func TestGenerateEnvrc_WithEnvVars(t *testing.T) {
	// Create template file in temp directory
	tmpDir := t.TempDir()
	setupEnvrcTemplate(t, tmpDir)

	config := &CampConfig{
		Env: map[string]string{
			"PROJECT_NAME": "camp",
			"GO_ENV":       "development",
			"DEBUG":        "true",
		},
	}

	result, err := GenerateEnvrc(tmpDir, config)

	if err != nil {
		t.Fatalf("GenerateEnvrc() error = %v", err)
	}

	// Check header
	if !strings.Contains(result, "#!/bin/bash") {
		t.Error("Generated .envrc missing shebang")
	}
	if !strings.Contains(result, "Generated by camp") {
		t.Error("Generated .envrc missing camp header")
	}

	// Check env vars are exported
	if !strings.Contains(result, "export PROJECT_NAME=\"camp\"") {
		t.Error("Generated .envrc missing PROJECT_NAME export")
	}
	if !strings.Contains(result, "export GO_ENV=\"development\"") {
		t.Error("Generated .envrc missing GO_ENV export")
	}
	if !strings.Contains(result, "export DEBUG=\"true\"") {
		t.Error("Generated .envrc missing DEBUG export")
	}
}

// setupEnvrcTemplate creates the .envrc template in the temp directory
func setupEnvrcTemplate(t *testing.T, tmpDir string) {
	templateDir := filepath.Join(tmpDir, "templates", "files")
	if err := os.MkdirAll(templateDir, 0755); err != nil {
		t.Fatalf("Failed to create template directory: %v", err)
	}

	templateContent := `#!/bin/bash
# Generated by camp - DO NOT EDIT MANUALLY
# To update: modify .camp.yml and run 'camp project sync'

{{- if .HasDevbox }}

# Load devbox environment (if devbox.json exists)
if [ -f devbox.json ]; then
  eval "$(devbox generate direnv)"
fi
{{- end }}
{{- if .EnvVars }}

# Camp project environment variables
{{- range $key, $value := .EnvVars }}
export {{ $key }}="{{ escapeEnvValue $value }}"
{{- end }}
{{- end }}
`

	templatePath := filepath.Join(templateDir, ".envrc.tmpl")
	if err := os.WriteFile(templatePath, []byte(templateContent), 0644); err != nil {
		t.Fatalf("Failed to write template: %v", err)
	}

	// Change working directory to temp dir so template path resolves correctly
	oldWd, _ := os.Getwd()
	os.Chdir(tmpDir)
	t.Cleanup(func() { os.Chdir(oldWd) })
}

func TestGenerateEnvrc_WithDevbox(t *testing.T) {
	tmpDir := t.TempDir()
	setupEnvrcTemplate(t, tmpDir)

	config := &CampConfig{
		Env: map[string]string{
			"TEST_VAR": "value",
		},
	}

	// Create devbox.json file
	devboxPath := filepath.Join(tmpDir, "devbox.json")
	if err := os.WriteFile(devboxPath, []byte("{}"), 0644); err != nil {
		t.Fatalf("Failed to create devbox.json: %v", err)
	}

	result, err := GenerateEnvrc(tmpDir, config)

	if err != nil {
		t.Fatalf("GenerateEnvrc() error = %v", err)
	}

	// Check devbox integration
	if !strings.Contains(result, "devbox generate direnv") {
		t.Error("Generated .envrc missing devbox integration")
	}

	// Check env var is still exported
	if !strings.Contains(result, "export TEST_VAR=\"value\"") {
		t.Error("Generated .envrc missing TEST_VAR export")
	}
}

func TestGenerateEnvrc_WithoutDevbox(t *testing.T) {
	tmpDir := t.TempDir()
	setupEnvrcTemplate(t, tmpDir)

	config := &CampConfig{
		Env: map[string]string{
			"TEST_VAR": "value",
		},
	}

	result, err := GenerateEnvrc(tmpDir, config)

	if err != nil {
		t.Fatalf("GenerateEnvrc() error = %v", err)
	}

	// Check devbox integration is NOT included
	if strings.Contains(result, "devbox generate direnv") {
		t.Error("Generated .envrc should not include devbox integration when devbox.json doesn't exist")
	}

	// Check env var is exported
	if !strings.Contains(result, "export TEST_VAR=\"value\"") {
		t.Error("Generated .envrc missing TEST_VAR export")
	}
}

func TestGenerateEnvrc_EscapeSpecialChars(t *testing.T) {
	tests := []struct {
		name          string
		envValue      string
		expectedValue string
	}{
		{
			name:          "escape quotes",
			envValue:      `hello "world"`,
			expectedValue: `export TEST="hello \"world\""`,
		},
		{
			name:          "escape dollar sign",
			envValue:      "$PATH:/usr/bin",
			expectedValue: "export TEST=\"\\$PATH:/usr/bin\"",
		},
		{
			name:          "escape backslash",
			envValue:      `C:\Users\test`,
			expectedValue: `export TEST="C:\\Users\\test"`,
		},
		{
			name:          "escape backticks",
			envValue:      "hello `whoami`",
			expectedValue: "export TEST=\"hello \\`whoami\\`\"",
		},
		{
			name:          "escape multiple special chars",
			envValue:      `"$VAR" and \path`,
			expectedValue: "export TEST=\"\\\"\\$VAR\\\" and \\\\path\"",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			setupEnvrcTemplate(t, tmpDir)

			config := &CampConfig{
				Env: map[string]string{
					"TEST": tt.envValue,
				},
			}

			result, err := GenerateEnvrc(tmpDir, config)

			if err != nil {
				t.Fatalf("GenerateEnvrc() error = %v", err)
			}

			if !strings.Contains(result, tt.expectedValue) {
				t.Errorf("GenerateEnvrc() = %q, want to contain %q", result, tt.expectedValue)
			}
		})
	}
}

func TestGenerateEnvrc_EmptyEnv(t *testing.T) {
	tmpDir := t.TempDir()
	setupEnvrcTemplate(t, tmpDir)

	config := &CampConfig{
		Env: map[string]string{},
	}

	result, err := GenerateEnvrc(tmpDir, config)

	if err != nil {
		t.Fatalf("GenerateEnvrc() error = %v", err)
	}

	// Should still have header
	if !strings.Contains(result, "#!/bin/bash") {
		t.Error("Generated .envrc missing shebang")
	}

	// Should not have export statements
	if strings.Contains(result, "export ") {
		t.Error("Generated .envrc should not have export statements when env is empty")
	}
}

func TestGenerateEnvrc_NilConfig(t *testing.T) {
	tmpDir := t.TempDir()
	setupEnvrcTemplate(t, tmpDir)

	result, err := GenerateEnvrc(tmpDir, nil)

	if err != nil {
		t.Fatalf("GenerateEnvrc() error = %v", err)
	}

	// Should still have header
	if !strings.Contains(result, "#!/bin/bash") {
		t.Error("Generated .envrc missing shebang")
	}

	// Should not have export statements
	if strings.Contains(result, "export ") {
		t.Error("Generated .envrc should not have export statements when config is nil")
	}
}

func TestEscapeEnvValue(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "no special chars",
			input:    "hello world",
			expected: "hello world",
		},
		{
			name:     "quotes",
			input:    `hello "world"`,
			expected: `hello \"world\"`,
		},
		{
			name:     "dollar sign",
			input:    "$PATH",
			expected: `\$PATH`,
		},
		{
			name:     "backslash",
			input:    `C:\Users`,
			expected: `C:\\Users`,
		},
		{
			name:     "backticks",
			input:    "`whoami`",
			expected: "\\`whoami\\`",
		},
		{
			name:     "multiple special chars",
			input:    `"$VAR" \path`,
			expected: `\"\$VAR\" \\path`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := escapeEnvValue(tt.input)
			if result != tt.expected {
				t.Errorf("escapeEnvValue(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}
